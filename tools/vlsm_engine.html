<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>VLSM Planner & Gap Analyzer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        background-color: #020617;
        color: #e2e8f0;
        font-family:
          "Inter", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
          monospace;
      }
      .glass {
        background: rgba(15, 23, 42, 0.8);
        backdrop-filter: blur(12px);
        border: 1px solid rgba(51, 65, 85, 0.5);
      }
      .gap-row {
        background: rgba(244, 63, 94, 0.05);
        border: 1px dashed rgba(244, 63, 94, 0.2);
      }
      .free-badge {
        background: rgba(16, 185, 129, 0.1);
        color: #10b981;
        border: 1px solid rgba(16, 185, 129, 0.3);
      }
      input,
      select {
        background: #1e293b !important;
        border: 1px solid #334155 !important;
        color: white !important;
      }
    </style>
  </head>
  <body class="p-4 md:p-8">
    <div class="max-w-6xl mx-auto">
      <header
        class="flex justify-between items-center mb-8 border-b border-slate-800 pb-6"
      >
        <div>
          <h1 class="text-3xl font-black tracking-tighter text-white uppercase">
            Network <span class="text-indigo-500">Mapper</span>
          </h1>
          <p class="text-slate-500 text-sm">
            Analyse de fragmentation et allocation VLSM optimisée
          </p>
        </div>
        <div class="text-right glass p-4 rounded-xl">
          <span
            class="text-[10px] font-bold text-slate-500 uppercase block mb-1"
            >Plus gros bloc libre</span
          >
          <div class="text-xl font-mono text-emerald-400" id="maxContiguous">
            -
          </div>
        </div>
      </header>

      <div class="grid grid-cols-12 gap-8">
        <div class="col-span-12 lg:col-span-4 space-y-6">
          <div class="glass p-6 rounded-2xl">
            <label
              class="text-xs font-bold uppercase text-indigo-400 mb-3 block"
              >Bloc Racine (VNET/VPC)</label
            >
            <input
              type="text"
              id="parentCidr"
              value="10.0.0.0/16"
              class="w-full rounded-xl px-4 py-3 font-mono text-lg outline-none focus:ring-2 focus:ring-indigo-500 transition"
              onchange="updateLayout()"
            />
          </div>

          <div class="glass p-6 rounded-2xl">
            <h2
              class="text-xs font-bold uppercase text-slate-400 mb-4 tracking-widest"
            >
              Nouveau segment
            </h2>
            <div class="space-y-4">
              <input
                type="text"
                id="newSubnetName"
                placeholder="Nom (ex: AKS-Nodes)"
                class="w-full rounded-lg px-3 py-2 text-sm outline-none"
              />
              <div class="flex gap-2">
                <select
                  id="newSubnetMask"
                  class="flex-1 rounded-lg px-3 py-2 text-sm outline-none"
                ></select>
                <button
                  onclick="addSubnet()"
                  class="bg-indigo-600 hover:bg-indigo-500 text-white px-4 rounded-lg text-sm font-bold transition"
                >
                  AJOUTER
                </button>
              </div>
            </div>
          </div>

          <div
            class="p-4 bg-amber-900/10 border border-amber-500/20 rounded-xl text-[11px] text-amber-200/70 leading-relaxed"
          >
            <strong>Règle d'or :</strong> Pour éviter la fragmentation, les
            sous-réseaux sont triés par taille. Un bloc de taille $2^n$ est
            toujours aligné sur une adresse dont les $n$ derniers bits sont à
            zéro.
          </div>
        </div>

        <div class="col-span-12 lg:col-span-8">
          <div class="glass rounded-2xl overflow-hidden shadow-2xl">
            <table class="w-full text-left border-collapse">
              <thead>
                <tr class="bg-slate-800/80">
                  <th
                    class="p-4 text-[10px] font-black text-slate-400 uppercase"
                  >
                    Type
                  </th>
                  <th
                    class="p-4 text-[10px] font-black text-slate-400 uppercase"
                  >
                    Réseau
                  </th>
                  <th
                    class="p-4 text-[10px] font-black text-slate-400 uppercase"
                  >
                    Plage utilisable
                  </th>
                  <th
                    class="p-4 text-[10px] font-black text-slate-400 uppercase text-right"
                  >
                    Taille
                  </th>
                </tr>
              </thead>
              <tbody id="mapTable" class="text-xs font-mono"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <script>
      let subnets = [];

      function ip2int(ip) {
        return (
          ip
            .split(".")
            .reduce((res, octet) => (res << 8) + parseInt(octet, 10), 0) >>> 0
        );
      }
      function int2ip(int) {
        return [
          (int >>> 24) & 0xff,
          (int >>> 16) & 0xff,
          (int >>> 8) & 0xff,
          int & 0xff,
        ].join(".");
      }

      function getLargestBlock(size, startIp) {
        if (size <= 0) return null;
        let mask = 32 - Math.floor(Math.log2(size));
        // Ajuster le masque pour l'alignement
        while (mask < 32 && startIp % Math.pow(2, 32 - mask) !== 0) {
          mask++;
        }
        return mask;
      }

      function init() {
        const select = document.getElementById("newSubnetMask");
        for (let i = 16; i <= 30; i++) {
          let opt = new Option(`/${i} (${Math.pow(2, 32 - i)} IPs)`, i);
          if (i === 24) opt.selected = true;
          select.add(opt);
        }
        updateLayout();
      }

      function addSubnet() {
        const name =
          document.getElementById("newSubnetName").value ||
          `Subnet ${subnets.length + 1}`;
        const mask = parseInt(document.getElementById("newSubnetMask").value);
        subnets.push({ name, mask, id: Date.now() });
        document.getElementById("newSubnetName").value = "";
        updateLayout();
      }

      function removeSubnet(id) {
        subnets = subnets.filter((s) => s.id !== id);
        updateLayout();
      }

      function updateLayout() {
        const parentInput = document.getElementById("parentCidr").value;
        if (!parentInput.includes("/")) return;

        const [baseIp, parentMask] = parentInput.split("/");
        const pMask = parseInt(parentMask);
        const pSize = Math.pow(2, 32 - pMask);
        const pStart = ip2int(baseIp) & (-1 << (32 - pMask));
        const pEnd = pStart + pSize;

        subnets.sort((a, b) => a.mask - b.mask);

        const tbody = document.getElementById("mapTable");
        tbody.innerHTML = "";

        let currentPtr = pStart;
        let maxFreeBlockSize = 0;

        subnets.forEach((s) => {
          const sSize = Math.pow(2, 32 - s.mask);
          const alignedStart = Math.ceil(currentPtr / sSize) * sSize;

          // 1. Détecter un GAP avant ce subnet
          if (alignedStart > currentPtr) {
            renderGap(currentPtr, alignedStart, tbody);
            maxFreeBlockSize = Math.max(
              maxFreeBlockSize,
              alignedStart - currentPtr,
            );
          }

          // 2. Rendre le Subnet
          const isOverflow = alignedStart + sSize > pEnd;
          renderRow(s, alignedStart, sSize, isOverflow, tbody);

          currentPtr = alignedStart + sSize;
        });

        // 3. Détecter le GAP final
        if (currentPtr < pEnd) {
          renderGap(currentPtr, pEnd, tbody);
          maxFreeBlockSize = Math.max(maxFreeBlockSize, pEnd - currentPtr);
        }

        // Update Header Stat
        const bestMask = getLargestBlock(maxFreeBlockSize, currentPtr); // Simplifié
        document.getElementById("maxContiguous").innerText =
          maxFreeBlockSize > 0
            ? `~ /${32 - Math.floor(Math.log2(maxFreeBlockSize))}`
            : "Complet";
      }

      function renderRow(s, start, size, overflow, container) {
        const tr = document.createElement("tr");
        tr.className = `border-b border-slate-800/50 ${overflow ? "bg-red-900/10" : "hover:bg-indigo-500/5"}`;
        tr.innerHTML = `
                <td class="p-4"><span class="text-indigo-400 font-bold">●</span> ${s.name}</td>
                <td class="p-4 ${overflow ? "text-red-400" : "text-slate-200"}">${int2ip(start)}/${s.mask}</td>
                <td class="p-4 text-slate-500 text-[10px]">${int2ip(start + 1)} - ${int2ip(start + size - 2)}</td>
                <td class="p-4 text-right">
                    <button onclick="removeSubnet(${s.id})" class="text-slate-600 hover:text-red-400">DEL</button>
                </td>
            `;
        container.appendChild(tr);
      }

      function renderGap(start, end, container) {
        const size = end - start;
        const largestMask = 32 - Math.floor(Math.log2(size));
        const tr = document.createElement("tr");
        tr.className = "gap-row text-slate-500";
        tr.innerHTML = `
                <td class="p-3 italic text-[10px]">Espace Libre</td>
                <td class="p-3">${int2ip(start)} <span class="text-[9px] opacity-50">...</span></td>
                <td class="p-3"><span class="free-badge text-[9px] px-2 py-0.5 rounded uppercase font-bold">Dispo: /${largestMask}</span></td>
                <td class="p-3 text-right text-slate-600">${size} IPs</td>
            `;
        container.appendChild(tr);
      }

      init();
    </script>
  </body>
</html>
